import { Parser } from 'lezer';
import { LezerLanguage, indentNodeProp, delimitedIndent, foldNodeProp, foldInside, LanguageSupport } from '@codemirror/language';
import { styleTags, tags } from '@codemirror/highlight';
import { ifNotIn, completeFromList } from '@codemirror/autocomplete';
import snippets from './snippets';

// This file was generated by lezer-generator. You probably shouldn't edit it.
const spec_Identifier = {__proto__:null,type:12, key:22, action:50, true:58, false:60, null:62, service:74, enum:80, flags:84};
const parser = Parser.deserialize({
  version: 13,
  states: ",rQYQPOOOhQPO'#DXOOQO'#Dc'#DcOOQO'#DY'#DYQYQPOOOyQPO'#CaO!OQPO'#DQOOQO,59s,59sO!WQPO,59sOOQO-E7W-E7WOOQO'#Cc'#CcO!iQPO,58{O!nQPO,59lO#VQPO,59lOOQO1G/_1G/_O#[QPO1G.gO#jQPO'#ChO#rQPO'#CfO#wQPO'#CvOOQO'#Ce'#CeOOQO'#DS'#DSO$PQPO'#CfO$UQPO'#CtOyQPO'#DTO$ZQPO1G/WO!nQPO1G/WO$`QPO7+$RO$eQPO'#CqOOQO,59[,59[O$mQPO,59QO$xQPO'#ClOOQO'#Cl'#ClO%aQPO,59bOOQO'#Ch'#ChO%fQPO,59QO%kQPO'#CpOOQO,59`,59`O%pQPO,59oOOQO7+$r7+$rO%uQPO7+$rOOQO<<Gm<<GmO%zQPO'#CsO&PQPO'#CrO&XQPO,59]O&^QPO'#CkO#wQPO'#CoOOQO'#Cj'#CjOOQO1G.l1G.lO&oQPO'#DZO&wQPO,59WO'qQPO1G.|O$mQPO1G.lO'xQPO1G/ZOOQO<<H^<<H^O$mQPO,59_O$PQPO'#D[O(QQPO,59^OOQO1G.w1G.wOOQO,59Y,59YO(YQPO,59ZOOQO,59u,59uOOQO-E7X-E7XO(_QPO'#C|OOQO'#Cx'#CxOOQO'#Cw'#CwOOQO7+$h7+$hO(gQPO7+$hOOQO7+$W7+$WO(nQPO'#DVO(vQPO7+$uOOQO1G.y1G.yOOQO,59v,59vOOQO-E7Y-E7YOOQO1G.u1G.uOOQO'#D]'#D]O({QPO,59hO)ZQPO,59hO)`QPO'#DPO)hQPO<<HSOOQO'#D_'#D_O)mQPO,59qOOQO<<Ha<<HaOOQO-E7Z-E7ZO)uQPO1G/SO'`QPO'#D^O*TQPO,59kOOQOAN=nAN=nOOQO-E7]-E7]OOQO,59x,59xOOQO-E7[-E7[",
  stateData: "*]~O!UOSPOS~ORQOUTOuUO!]PO~ORQOUTOuUO![VO!]PO~ORYO~ORYOW[O~ORQOUTOuUO![^O!]PO~OW_O~OR`OZeOifOxgOzgO!_bOSvP~OWiO~OR`OZeOifO!_bO~O!]kO][X~O]mO~ORnOaoO~ORqO~ORsO~OSvO~OSxO~ORqO![fP~ORnOaoO!Y}O~O!W!QO]`XS`X!X`X!Z`X![`X!^`X~O]!SO~O]!TO~O!]kO~OW!UO~OS!VO~O]!WO~O!^!XO![fX~O![!ZO~O!X![OS_X!Z_X![_X!^_X~OR!^Oa!^O~O!W!QO]`aS`a!X`a!Z`a![`a!^`a~Om!aOn!aOo!aOq!`Or!aO~O!Y!dO~P'`OR!fOSyP~O!^!XO![fa~O!Z!kO~Oq!lO!W!nO~O!ZsP~P'`OR!qOSyX~OS!sO~Oq!lOSpa!Zpa!^pa~Oq!lO~O!^!vO!ZsX~O!Z!xO~OR!qOSya~Oq!lOSpi!Zpi!^pi~O!^!vO!Zsa~O",
  goto: "&P!WPPPPP!XP!_P!h!oP!tP#Q#Z#cP#Z#l#q#y#}$Q!oP!o$W$aPPP$fPP$k!XP$n$tP$xP!X${%V%]%c%m%sPPP%yXQOPSWQZTQ]URugSd[iRj_Vc[_iUa[_iQreTyk!XQ!PmQ!e!TR!h!WU!Om!T!WR!]}QpbX|m}!T!WV!Om!T!WUc[_iRtfTl`sR{kQzkR!i!XQ!c!SQ!o!dR!z!vV!b!S!d!vV!a!S!d!vR!p!dQh[RwiTd[iR!g!UQSOQWPTXSWQ!RnR!_!RQ!YzR!j!YQ!m!`S!t!m!uR!u!nQ!w!oR!{!wQ!r!fR!y!rXROPSW",
  nodeNames: "âš  LineComment Program Identifier } TypeDefinition type DefinitionName { TypeBodyDefinition FieldDefinition key VariableName : FieldType RequiredType TypeRefName CapitalIdentifier OptionalType MultiValuedType FunctionDefinition FormalParameters CommaSepParams FormalParameter ActionDefinition action AnnotationDefinition AnnotationValue Literal true false null NumberLiteral Digits StringLiteral CommaSepAnnotationValues ServiceDefinition service ServiceBodyDefinition EnumDefinition enum SpaceSepIds flags Application",
  maxTerm: 61,
  skippedNodes: [0,1],
  repeatNodeCount: 6,
  tokenData: "&^~RfXY!gYZ!g]^!gpq!grs!xtu#pxy$Uyz$Z|}$`!O!P$e!P!Q$j!Q![${![!]%T!a!b%Y!b!c%_!c!}%d!}#O%x#P#Q%}#R#S#p#T#o#p#o#p&S#q#r&X~!lS!U~XY!gYZ!g]^!gpq!g~!{UOY!xZr!xrs#_s#O!x#O#P#d#P~!x~#dOr~~#gROY!xYZ!xZ~!x~#uTR~tu#p!Q![#p!c!}#p#R#S#p#T#o#p~$ZO!]~~$`O![~~$eO!^~~$jO!W~~$mP!P!Q$p~$uQP~OY$pZ~$p~%QPq~!Q![${~%YO]~~%_O!X~~%dO!_~~%iTa~tu%d!Q![%d!c!}%d#R#S%d#T#o%d~%}O!Y~~&SO!Z~~&XOW~~&^OS~",
  tokenizers: [0],
  topRules: {"Program":[0,2]},
  specialized: [{term: 3, get: value => spec_Identifier[value] || -1}],
  tokenPrec: 0
});

const rsdlLanguage = LezerLanguage.define({
    parser: parser.configure({
        props: [
            indentNodeProp.add({
                Application: delimitedIndent({ closing: ")", align: false })
            }),
            foldNodeProp.add({
                Application: foldInside
            }),
            styleTags({
                Identifier: tags.variableName,
                Boolean: tags.bool,
                String: tags.string,
                LineComment: tags.lineComment,
                "( )": tags.paren
            })
        ]
    }),
    languageData: {
        commentTokens: { line: ";" }
    }
});
function rsdl() {
    return new LanguageSupport(rsdlLanguage, rsdlLanguage.data.of({
        autocomplete: ifNotIn(["LineComment", "StringLiteral"], completeFromList(snippets))
    }));
}

export { rsdl, rsdlLanguage };
